using Code420.SfBlazorPlus.BaseComponents.TabBase;
using Code420.SfBlazorPlus.Pages.Orchestrator;
using Microsoft.AspNetCore.Components;
using Syncfusion.Blazor;
using Syncfusion.Blazor.Navigations;

namespace Code420.SfBlazorPlus.OrchestratorComponents.OrchestratorTabMananger
{
    /// <summary>
    /// Responsible for managing all Orchestrator Tab Items.
    /// Provides sole access to the underlying TabBase component.
    /// Will handle events generated by Tab Items and make appropriate calls through 
    /// the Orchestrator to coordinate events.
    /// Will provide public menthods to respond to events passed through the Orchestrator.
    /// </summary>
    public partial class OrchestratorTabManager : ComponentBase
    {

        #region Component Parameters

        #region Base Parameters

        // ==================================================
        // Base Parameters
        // ==================================================

        /// <summary>
        /// Contains the reference to the <see cref="Orchestrator"/> parent.
        /// </summary>
        [Parameter]
        public Orchestrator OrchestratorRef { get; set; }

        /// <summary>
        /// String value specifying the name of the Orchestrator Tab component loaded when the the Tab Manager component is loaded.
        /// </summary>
        [Parameter]
        public string InitialMenuItemId { get; set; } = default;

        #endregion


        #region Event Callback Parameters

        // ==================================================
        // Event Callback Parameters
        // ==================================================


        #endregion


        #region CSS Parameters

        // ==================================================
        // CSS Styling Parameters
        // ==================================================


        #endregion

        #endregion



        #region Callback Events Invoked from Underlying Components

        // ==================================================
        // Methods used as Callback Events from the underlying component(s)
        // ==================================================

        private void MyAddedHandler(AddEventArgs args)
        {
            //Debug.WriteLine("MyAddedHandler method invoked.");
        }

        private void MyAddingHandler(AddEventArgs args)
        {
            //Debug.WriteLine("MyAddingHandler method invoked.");
        }

        private void MyCreatedHandler(object args)
        {
            //Debug.WriteLine("MyCreatedHandler method invoked.");
        }

        private void MyDestroyedHandler(object args)
        {
            //Debug.WriteLine("MyDestroyedHandler method invoked.");
        }

        private void MyDraggedHandler(DragEventArgs args)
        {
            //Debug.WriteLine("MyDraggedHandler method invoked.");
        }

        private void MyOnDragStartHandler(DragEventArgs args)
        {
            //Debug.WriteLine("MyOnDragStartHandler method invoked.");
        }

        private void MyOnRemovedHandler(RemoveEventArgs args)
        {
            //Debug.WriteLine("MyOnRemovedHandler method invoked.");

            //  Get the index of the record in OrchestratorTabs for the Tab Item being closed
            //  If we found the record, Reset the TabIndex and IsLoaded fields for the record
            int index = OrchestratorRef.OrchestratorTabs.FindIndex(x => x.TabIndex == args.RemovedIndex);
            if (index == -1) return;
            OrchestratorRef.OrchestratorTabs[index].TabIndex = -1;
            OrchestratorRef.OrchestratorTabs[index].IsLoaded = false;

            // SfTabs reorders the TabItems list when a Tab Item is removed.
            // Need to re-sync the OrchestratorTabs list with the TabItems list.
            SyncTabItemsWithOrchestratorTabs();

            // Right now, make the first tab the active tab.
            InvokeAsync(async () => await SelectAsync(0));
        }

        private void MyOnRemovingHandler(RemoveEventArgs args)
        {
            //Debug.WriteLine("MyOnRemovingHandler method invoked.");
        }

        private void MyOnSelectedHandler(SelectEventArgs args)
        {
            //Debug.WriteLine($"MyOnSelectedHandler method invoked. Index = { selectedItem }");
        }

        private void MyOnSelectingHandler(SelectingEventArgs args)
        {
            //Debug.WriteLine("MyOnSelectingHandler method invoked.");
        }

        private void MyOnSelectedItemChangedHandler(int index)
        {
            // Update the active tab index tracker
            selectedItem = index;
            //Debug.WriteLine($"MyOnSelectedItemChangedHandler method invoked. Index = { index }");
        }



        #endregion



        #region Instance Variables

        // ==================================================
        // Instance variables
        // ==================================================

        private TabBase tabbase;                        // Reference to the TabBase component
        private List<TabItem> tabItem;                  // List of Orchestrator Tabs initially loaded by the TabeBase component
        private int selectedItem = 0;                   // Tracks the index (in tabbase.TabItems) of the active tab
        private int initialMenuItemIndex = -1;          // Contains index on OrchetratorTabs list for the InitialMenuItemId Orchestrator Tab

        #endregion



        #region Injected Dependencies

        // Injected Dependencies



        // Dependency Injection


        #endregion



        #region Constructors


        // ==================================================
        // Constructors
        // ==================================================

        // This method is executed whenever the parent renders.
        // Parameters that were passed into the component are contained in a ParameterView.
        //  This is a good point at which to make asynchronous calls to a server (for example)
        //  based on the state passed into the component.
        // The component’s [Parameter] properties are assigned their values when you call
        //  base.SetParametersAsync(parameters) inside your override.
        // It is also the correct place to assign default parameter values.
        public override async Task SetParametersAsync(ParameterView parameters)
        {
            await base.SetParametersAsync(parameters);
        }

        // Once the state from the ParameterCollection has been assigned to the component’s
        //  [Parameter] properties, these methods are executed. This is useful in the same way
        //  as SetParametersAsync, except it is possible to use the component’s state.
        // This method is only executed once when the component is first created.If the parent
        //  changes the component’s parameters at a later time, this method is skipped.
        // When the component is a @page, and our Blazor app navigates to a new URL that renders
        //  the same page, Blazor will reuse the current object instance for that page.Because the
        //  object is the same instance, Blazor does not call IDisposable.Dispose on the object,
        //  nor does it execute its OnInitialized method again.
        protected override async Task OnInitializedAsync()
        {
            await base.OnInitializedAsync();

            //
            //  Get the index of the InitialMenuItemId element from the OrchestratorTabs list
            // If the element was not found intialize the tabIem as an empty list.
            //  If the element was found, build the tabItem list (used to initialize the TabBase component)
            //  Set the IsLoaded field for the element's record in OrchestratorTabs
            //
            //  NOTE: In OnAfterRenderAsync the index of the InitialMenuItemId Orchestrator Tab in the tabbase.TabItems list
            //          will be discovered and tied back to the corresponding OrchestratorTab.TabIndex field.
            //
            initialMenuItemIndex = OrchestratorRef.FindOrchestratorTabIndex(InitialMenuItemId);
            if (initialMenuItemIndex == -1)
            {
                tabItem = new List<TabItem>();
            }
            else
            {
                tabItem = new List<TabItem>() { OrchestratorRef.OrchestratorTabs[initialMenuItemIndex].TabDefinition };
                OrchestratorRef.OrchestratorTabs[initialMenuItemIndex].IsLoaded = true;

            }
        }

        // This method will be executed immediately after OnInitializedAsync if this is a new
        //  instance of a component. If it is an existing component that is being re-rendered because
        //  its parent is re-rendering then the OnInitialized* methods will not be executed, and this
        //  method will be executed immediately after SetParametersAsync instead
        protected override async Task OnParametersSetAsync()
        {
            await base.OnParametersSetAsync();
        }

        // This is the first place that the State should be changed
        //
        // This method is executed every time Blazor has re-generated the component’s RenderTree.
        //  This can be as a result of the component’s parent re-rendering, the user interacting with the component
        //  (e.g. a mouse-click), or if the component executes its StateHasChanged method to invoke a re-render.
        // This method has a single parameter named firstRender. This parameter is true only the first time the
        //  method is called on the current component, from there onwards it will always be false. In cases where
        //  additional component hook-up is required (for example, via JavaScript) it is useful to know this is the
        //  first render.
        // It is not until after the OnAfterRender method have executed that it is safe to use any references to
        //  components set via the @ref directive. And it is not until after the OnAfterRender method have been
        //  executed with firstRender set to true that it is safe to use any references to HTML elements set via
        //  the @ref directive
        protected override async Task OnAfterRenderAsync(bool firstRender)
        {
            await base.OnAfterRenderAsync(firstRender);

            // Only on first render...
            //  If the index of the InitialMenuItemId element from the OrchestratorTabs list was found (in OnInitializedAsync)...
            //      Set its TabIndex field to the index in the tabbase.TabItems list for the InitialMenuItemId.
            if (firstRender)
            {
                if (initialMenuItemIndex == -1) return;
                int index = GetTabItemIndex(InitialMenuItemId);
                if (index == -1) return;
                OrchestratorRef.OrchestratorTabs[initialMenuItemIndex].TabIndex = index;
            }
        }
        #endregion



        #region Public Methods Providing Access to the Underlying Components to the Consumer

        // ==================================================
        // Public Methods providing access to the underlying component to the consumer
        // ==================================================

        /// <summary>
        /// Adds a list of Tab items to the Tab.
        /// </summary>
        /// <param name="items">List of <see cref="TabItem"/> to add to the Tab.</param>
        /// <param name="index">Index value that determines where the items to be added</param>
        public async Task AddTabAsync(List<TabItem> items, int indexTabItems, int orchestratorTabIndex)
        {
            // Add the passed Tab Item to the tabbase.TabItems
            // Save the index of the new TabItems element to the corresponding OrchestratorTabs record (orchestratorTabIndex)
            // Update the IsLoaded field in the corresponding OrchestratorTabs record (orchestratorTabIndex)
            await this.tabbase.AddTabAsync(items, indexTabItems);
            int index = GetTabItemIndex(OrchestratorRef.OrchestratorTabs[orchestratorTabIndex].MenuItemId);
            if (index == -1) return;
            OrchestratorRef.OrchestratorTabs[orchestratorTabIndex].TabIndex = index;
            OrchestratorRef.OrchestratorTabs[orchestratorTabIndex].IsLoaded = true;
        }

        /// <summary>
        /// Disables/enables the Tab component.
        /// </summary>
        /// <param name="disable">Boolean value specifying is the Tab component is disabled (true) or enabled.</param>
        public async Task DisableAsync(bool disable) => await this.tabbase.DisableAsync(disable);

        /// <summary>
        /// Enables or disables a specific tab item.
        /// </summary>
        /// <param name="index">Integer value specifying the index of the tab.</param>
        /// <param name="isEnable">Boolean value specifying is the tab is enabled (true) or disabled.</param>
        /// <returns></returns>
        public async Task EnableTabAsync(int index, bool isEnable = true) => await this.tabbase.EnableTabAsync(index, isEnable);

        /// <summary>
        /// Returns the content element of the tab with the specified index.
        /// </summary>
        /// <param name="index">Integer value specifying the index of the tab whose content is to returned.</param>
        /// <returns>A <see cref="DOM"/> object containg the contents of the tab.</returns>
        public async Task<DOM> GetTabContentAsync(int index)
        {
            return await this.tabbase.GetTabContentAsync(index);
        }

        /// <summary>
        /// Returns the header element of the tab with the specified index.
        /// </summary>
        /// <param name="index">Integer value specifying the index of the tab whose content is to returned.</param>
        /// <returns>A <see cref="DOM"/> object containg the header element of the tab.</returns>
        public async Task<DOM> GetTabItemAsync(int index)
        {
            return await this.tabbase.GetTabItemAsync(index);
        }

        /// <summary>
        /// Show/hides a tab based on the specified index.
        /// </summary>
        /// <param name="index">Integer value spefifying the index of the tab to show/hide.</param>
        /// <param name="show">Boolean value specifying if the tab is shown (true) or hidden.</param>
        /// <returns></returns>
        public async Task HideTabAsync(int index, bool show) => await this.tabbase.HideTabAsync(index, show);

        /// <summary>
        /// Refresh the entire Tab component.
        /// </summary>
        public async Task RefreshAsync() => await this.tabbase.RefreshAsync();

        /// <summary>
        /// Removes an entire tab from the collection of tabs.
        /// </summary>
        /// <param name="index">Integer value spefifying the index of the tab to remove.</param>
        public async Task RemoveTabAsync(int index) => await this.tabbase.RemoveTabAsync(index);

        /// <summary>
        /// Activates a tab based on the specified index.
        /// </summary>
        /// <param name="index">Integer value spefifying the index of the tab to activate.</param>
        public async Task SelectAsync(int index)
        {
            // Just to be safe, bail if the TabItems list is empty.
            if ((tabbase.TabItems is null) || (tabbase.TabItems.Count == 0)) return;

            // Change the active tab and update our tracker.
            await tabbase.SelectAsync(index);
            selectedItem = index;
        }

        /// <summary>
        /// Gets the index of the last item in the TabItems list.
        /// </summary>
        /// <returns>Integer value representing the highest index of the TabItems list, or -1 if there are no items.</returns>
        public int GetLastTabItemsIndex()
        {
            return (tabbase.TabItems is not null) ? tabbase.TabItems.Count - 1 : -1;
        }


        #endregion



        #region Private Methods for Internal Use Only

        //
        // Get the index of the passed Orchestrator Tab in the tabbase.TabItems list.
        //
        private int GetTabItemIndex(string menuItemId)
        {
            return (tabbase.TabItems is not null) ? tabbase.TabItems.FindIndex(X => X.CssClass == menuItemId) : -1;
        }

        //
        // Synchronizes the tabbase.TabItems list with the OrchestratorTabs list.
        // This is needed because when a Tab is closed, the TabItems indicies will change for some/all Tab Items
        //  which means the OrchestratorTabs[].TabIndex fields are invalidated.
        //
        private void SyncTabItemsWithOrchestratorTabs()
        {
            // Bail if tabbase.TabItems is empty
            if (tabbase.TabItems.Count == 0) return;

            //
            // I know this seems silly (versus using a for loop, but is consistent with the method
            //  used to set OrchestratorTabs[].TabIndex is all other methods.
            //
            // Remember: The Tab Item CssClass field == OrchestratorTabs.MenuItemId
            //
            foreach(TabItem tabitem in tabbase.TabItems)
            {
                int orchestratorTabsIndex = OrchestratorRef.FindOrchestratorTabIndex(tabitem.CssClass);
                int tabItemIndex = GetTabItemIndex(tabitem.CssClass);
                OrchestratorRef.OrchestratorTabs[orchestratorTabsIndex].TabIndex = tabItemIndex;
            }
        }

        #endregion

    }
}
